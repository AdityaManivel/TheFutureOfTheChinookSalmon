# -*- coding: utf-8 -*-
"""TheFutureOfTheChinookSalmon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uWVyRH6J5Lq9PKTiQSybwzB-ZeHbsGtV
"""

# Imports necessary for pytorch and graph visualization
import torch
from torch import nn
from torch.nn.modules.activation import ReLU
import torch.optim as optim
import matplotlib.pyplot as plt
import pandas as pd

# Data set used to train AI model
data = 'https://raw.githubusercontent.com/AdityaManivel/WaterHacksProject/main/TrainingDataProj.csv.csv'
df = pd.read_csv(data)
df.head(11)

# Standardization of the training data set
winterWaterTempMean = df['WinterWaterTemp'].mean()
winterWaterTempStd = df['WinterWaterTemp'].std()
df['WinterWaterTemp'] = (df['WinterWaterTemp'] - winterWaterTempMean) / winterWaterTempStd


summerWaterTempMean = df['SummerWaterTemp'].mean()
summerWaterTempStd = df['SummerWaterTemp'].std()
df['SummerWaterTemp'] = (df['SummerWaterTemp'] - summerWaterTempMean) / summerWaterTempStd


chinookPopulationMean = df['ChinookPopulation'].mean()
chinookPopulationStd = df['ChinookPopulation'].std()
df['ChinookPopulation'] = (df['ChinookPopulation'] - chinookPopulationMean) / chinookPopulationStd

df.head(11)

device = 'cuda' if torch.cuda.is_available() else 'cpu'

# Inputs for data set
inputs = ['WinterWaterTemp','SummerWaterTemp']
x = torch.tensor(df[inputs].values, dtype=torch.float,device=device)

# Outputs for data set
outputs = ['ChinookPopulation']
y = torch.tensor(df[outputs].values, dtype=torch.float,device=device)

x[0:11]

y[0:11]

# Creates the pytorch neural network
model = nn.Sequential(
    nn.Linear(2, 100),
    nn.ReLU(),
    nn.Linear(100, 1),
)

model.to(device)

# Keeps track of losses
criterion = nn.MSELoss()

# Improves accuracy of AI model
optimizer = optim.SGD(model.parameters(), lr=0.01,momentum=0.8)

# Trains the AI model and improves it through each iteration
for epoch in range(11):
    losses = 0
    for i in range(len(x)):
        ypred = model(x[i])
        loss = criterion(ypred, y[i])
        losses += loss.item()
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    # Prints the total losses each time in the loop.
    print("losses ", losses)

#plots the values predicted population vs. actual population
def graph(model, x, y , min, max):

    model.eval()

    predictions=[]
    actual=[]

    x.to(device)
    y.to(device)
    model.to(device)

    for i in range(len(x)):
        pred = model(x[i])
        pred = pred*chinookPopulationStd+chinookPopulationMean
        act = y[i]*chinookPopulationStd+chinookPopulationMean


        predictions.append(pred.tolist())
        actual.append(act.item())


    plt.scatter(actual, predictions)
    plt.xlabel('Actual Chinook Salmon Population')
    plt.ylabel('Predicted Chinook Salmon Population')
    plt.plot([min,max], [min,max])
    plt.xlim(min, max)
    plt.ylim(min, max)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

graph(model, x, y, 0, 100000)

